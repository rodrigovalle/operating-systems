#!/bin/python3
import sys
import pprint
#from helper import block, inode
from csv_helper import csv_reader

# directory with csv files can be specified as the first argument
# if no argument, assume csv files are in the current directory
cur_dir = ""
if len(sys.argv) == 2:
    cur_dir = sys.argv[1]

# globals
pp = pprint.PrettyPrinter(indent=4)
r = csv_reader(cur_dir)

def main():

    super_csv = r.entry_list('super.csv')
    group_csv = r.entry_list('group.csv')
    bitmap_csv = r.entry_list('bitmap.csv')
    inode_csv = r.entry_list('inode.csv')

    # build a model of the file system, which we'll check for inconsistencies
    blockBitmapBlocks = []
    inodeBitmapBlocks = []

    blockFreeList = []
    inodeFreeList = []

    inodeAllocated = {} # <key=inode_num, value=Inode class>
    blockAllocated = {} # <key=block_num, value=Block class>

    max_inode_nr = super_csv[0]['total_inodes']
    max_block_nr = super_csv[0]['total_blocks'] - 1  # account for index offset


    for group in group_csv:
        blockBitmapBlocks.append(group['block_bitmap_block'])
        inodeBitmapBlocks.append(group['inode_bitmap_block'])
    

    for entry in bitmap_csv:
        n = entry['element_number']
        if entry['bitmap_block'] in blockBitmapBlocks:  # found free block
            blockFreeList.append(n)
        elif entry['bitmap_block'] in inodeBitmapBlocks:  # found free inode
            inodeFreeList.append(n)


    for inode in inode_csv:
        inode_nr = inode['inode_number']

        # direct blocks
        try:
            for ptr in inode['block_pointers'][:12]:
                if ptr == 0:  # should we keep traversing the array or stop?
                    raise KeyError

                if ptr in blockAllocated:
                    print(ptr)
                    blockAllocated[ptr] += 1
                else:
                    blockAllocated[ptr] = 1

            # indirect blocks
            for lvl, ptr in enumerate(inode['block_pointers'][12:], start=1):
                for sub_block in follow_indirect(ptr, lvl):
                    if ptr == 0:
                        raise KeyError

                    if ptr in blockAllocated:
                        print(ptr)
                        blockAllocated[sub_block] += 1
                    else:
                        blockAllocated[sub_block] = 1
        except KeyError:
            pass

def follow_indirect(blk, lvl):
    indirect_csv = r.entry_list('indirect.csv')
    allocated_blocks = []

    for entry in indirect_csv:
        if blk == entry['containing_block']:
            sub_block = entry['block_pointer']
            allocated_blocks.append(sub_block)
            if lvl == 1:
                allocated_blocks += follow_indirect(sub_block, lvl - 1)

    return allocated_blocks

if __name__ == '__main__':
    main()
