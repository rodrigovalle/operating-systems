#!/bin/python3
import sys
import pprint
import objects as obj
from logger import warning
from csv_helper import csv_reader


# directory with csv files can be specified as the first argument
# if no argument, assume csv files are in the current directory
cur_dir = ""
if len(sys.argv) == 2:
    cur_dir = sys.argv[1]

# globals
pp = pprint.PrettyPrinter(indent=4)
r = csv_reader(cur_dir)
warn = warning('lab3b_check.txt')


def main():
    super_csv = r.entry_list('super.csv')
    group_csv = r.entry_list('group.csv')
    bitmap_csv = r.entry_list('bitmap.csv')
    inode_csv = r.entry_list('inode.csv')
    directory_csv = r.entry_list('directory.csv')

    # build a model of the file system, which we'll check for inconsistencies
    blockBitmapBlocks = []
    inodeBitmapBlocks = []

    blockFreeList = []
    inodeFreeList = []

    inodeAllocated = {} # <key=inode_num, value=Inode class>
    blockAllocated = {} # <key=block_num, value=Block class>
    directoryTable = {}

    inodes_per_group = super_csv[0]['inodes_per_group']
    max_inode_nr = super_csv[0]['total_inodes']
    max_block_nr = super_csv[0]['total_blocks'] - 1  # account for index offset


    # populate blockBitmapBlocks and inodeBitmapBlocks
    for group in group_csv:
        blockBitmapBlocks.append(group['block_bitmap_block'])
        inodeBitmapBlocks.append(group['inode_bitmap_block'])
    

    # populate blockFreeList and inodeFreeList
    for entry in bitmap_csv:
        n = entry['element_number']
        if entry['bitmap_block'] in blockBitmapBlocks:  # found free block
            blockFreeList.append(n)
        elif entry['bitmap_block'] in inodeBitmapBlocks:  # found free inode
            inodeFreeList.append(n)


    # populate blockAllocated and inodeAllocated
    """
    inode.csv contains the field: number of blocks.  We need to make it so the
    code iterates through only that number of blocks that are actually
    allocated (given to us by this number of blocks field).  If any of these
    allocated blocks have a value of 0 then we should output the error like so:

    if blocknum == 0 or blocknum > maxblocknum
        INVALID_BLOCK_ERROR
    else 
        put the block corresponding to blocknum into blockAllocated dictionary
    """
    for inode in inode_csv:
        inode_nr = inode['inode_number']
        inodeAllocated[inode_nr] = obj.inode(inode_nr, inode['ref_count'])

        for i, ptr in enumerate(inode['block_pointers']):
            if ptr == 0:  # should we keep traversing the array or stop?
                continue

            # direct blocks
            if i < 12:
                if ptr not in blockAllocated:
                    blockAllocated[ptr] = obj.block(ptr)
                blockAllocated[ptr].add_reference((inode_nr, i))

            # indirect blocks
            elif i >= 12:
                lvl = i - 11  # 1 for single indirect, 2 for double, etc

                for sub_block in follow_indirect(ptr, lvl):
                    sub_blk_ptr, entrynum = sub_block

                    if sub_blk_ptr not in blockAllocated:
                        blockAllocated[sub_blk_ptr] = obj.block(sub_blk_ptr)
                    blockAllocated[sub_blk_ptr].add_reference(sub_block)

    referencedInodes = {}
    # populate inode reference lists in inodeAllocated
    for dir_entry in directory_csv:
        child_inode_num = dir_entry['entry_inode']
        parent_inode_num = dir_entry['parent_inode_number']
        entry_num = dir_entry['entry_number']
        inode_name = dir_entry['name']

        # populate the directory table
        if parent_inode_num != child_inode_num or parent_inode_num == 2:
            directoryTable[child_inode_num] = parent_inode_num

        # update inodeAllocated
        if child_inode_num in inodeAllocated:
            inodeAllocated[child_inode_num].add_reference(
                (parent_inode_num, entry_num)
            )

        # update the list of all inodes referenced by directories
        if child_inode_num not in referencedInodes:
            referencedInodes[child_inode_num] = obj.inode(child_inode_num, 0)
        referencedInodes[child_inode_num].add_reference(
            (parent_inode_num, entry_num)
        )

        # checks for the "." and ".." entries
        if entry_num == 0 and child_inode_num != parent_inode_num:
            warn.INCORRECT_DIR_ENTRY(
                parent_inode_num,
                inode_name,
                child_inode_num,
                parent_inode_num
            )
        elif entry_num == 1 and child_inode_num != directoryTable[parent_inode_num]:
            warn.INCORRECT_DIR_ENTRY(
                parent_inode_num,
                inode_name,
                child_inode_num,
                directoryTable[parent_inode_num]
            )
    
    for inode_ref_by_dir in referencedInodes.values():
        if inode_ref_by_dir.inode_number not in inodeAllocated:
            warn.UNALLOCATED_INODE(
                inode_ref_by_dir.inode_number,
                inode_ref_by_dir.referenced_by
            )


    for i in inodeAllocated.values():
        linkCnt = len(i.referenced_by)
        if i.inode_number > 10 and linkCnt == 0:
            warn.MISSING_INODE(
                i.inode_number,
                group_csv[i.inode_number // inodes_per_group]['inode_bitmap_block']
            )
        elif linkCnt != i.refcount:
            warn.INODE_LINKCOUNT(
                i.inode_number,
                i.refcount,
                linkCnt
            )

# ???
#    for i in inodeFreeList:
#        if i.inode_number in inode ^ :
#            warn.UNALLOCATED_INODE_ERROR(
#                i.inode_number,
#            )

    for n in range(11, max_inode_nr):
        if n not in inodeFreeList and n not in inodeAllocated:
            warn.MISSING_INODE(
                n,
                group_csv[n // inodes_per_group]['inode_bitmap_block']
            )

    for b in blockAllocated.values():
        if len(b.referenced_by) > 1:
            reflist = [ref for ref in b.referenced_by]
            warn.DUPLICATELY_ALLOCATED_BLOCK(
                b.block_number,
                reflist
            )

    for b in blockAllocated.values():
        if b.block_number in blockFreeList:
            warn.UNALLOCATED_BLOCK(
                b.block_number,
                b.referenced_by
            )

def follow_indirect(blk, lvl):
    indirect_csv = r.entry_list('indirect.csv')
    allocated_blocks = []

    for entry in indirect_csv:
        if blk == entry['containing_block']:
            sub_block = (entry['block_pointer'], entry['entry_number'])
            allocated_blocks.append(sub_block)
            if lvl == 1:
                allocated_blocks += follow_indirect(sub_block, lvl - 1)

    return allocated_blocks


if __name__ == '__main__':
    main()
